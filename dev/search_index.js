var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = InferenceObjects","category":"page"},{"location":"#InferenceObjects","page":"Home","title":"InferenceObjects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for InferenceObjects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [InferenceObjects]","category":"page"},{"location":"#InferenceObjects.AsSlice","page":"Home","title":"InferenceObjects.AsSlice","text":"AsSlice{T<:LookupArrays.Selector} <: LookupArrays.Selector{T}\n\nAsSlice(selector)\n\nSelector that ensures selected indices are arrays so that slicing occurs.\n\nThis is useful to ensure that selecting a single index still returns an array.\n\n\n\n\n\n","category":"type"},{"location":"#InferenceObjects.Dataset","page":"Home","title":"InferenceObjects.Dataset","text":"Dataset{L} <: DimensionalData.AbstractDimStack{L}\n\nContainer of dimensional arrays sharing some dimensions.\n\nThis type is an DimensionalData.AbstractDimStack that implements the same interface as DimensionalData.DimStack and has identical usage.\n\nWhen a Dataset is passed to Python, it is converted to an xarray.Dataset without copying the data. That is, the Python object shares the same memory as the Julia object. However, if an xarray.Dataset is passed to Julia, its data must be copied.\n\nConstructors\n\nDataset(data::DimensionalData.AbstractDimArray...)\nDataset(data::Tuple{Vararg{<:DimensionalData.AbstractDimArray}})\nDataset(data::NamedTuple{Keys,Vararg{<:DimensionalData.AbstractDimArray}})\nDataset(\n    data::NamedTuple,\n    dims::Tuple{Vararg{DimensionalData.Dimension}};\n    metadata=DimensionalData.NoMetadata(),\n)\n\nIn most cases, use convert_to_dataset to create a Dataset instead of directly using a constructor.\n\n\n\n\n\n","category":"type"},{"location":"#InferenceObjects.InferenceData","page":"Home","title":"InferenceObjects.InferenceData","text":"InferenceData{group_names,group_types}\n\nContainer for inference data storage using DimensionalData.\n\nThis object implements the InferenceData schema.\n\nInternally, groups are stored in a NamedTuple, which can be accessed using parent(::InferenceData).\n\nConstructors\n\nInferenceData(groups::NamedTuple)\nInferenceData(; groups...)\n\nConstruct an inference data from either a NamedTuple or keyword arguments of groups.\n\nGroups must be Dataset objects.\n\nInstead of directly creating an InferenceData, use the exported from_xyz functions or convert_to_inference_data.\n\n\n\n\n\n","category":"type"},{"location":"#Base.convert-Tuple{Type{InferenceData}, Any}","page":"Home","title":"Base.convert","text":"convert(::Type{InferenceData}, obj)\n\nConvert obj to an InferenceData.\n\nobj can be any type for which convert_to_inference_data is defined.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{InferenceData, Vararg{Any}}","page":"Home","title":"Base.getindex","text":"Base.getindex(data::InferenceData, groups::Symbol; coords...) -> Dataset\nBase.getindex(data::InferenceData, groups; coords...) -> InferenceData\n\nReturn a new InferenceData containing the specified groups sliced to the specified coords.\n\ncoords specifies a dimension name mapping to an index, a DimensionalData.Selector, or an IntervalSets.AbstractInterval.\n\nIf one or more groups lack the specified dimension, a warning is raised but can be ignored. All groups that contain the dimension must also contain the specified indices, or an exception will be raised.\n\nExamples\n\nSelect data from all groups for just the specified id values.\n\njulia> using InferenceObjects, DimensionalData\n\njulia> idata = from_namedtuple(\n           (θ=randn(4, 100, 4), τ=randn(4, 100));\n           prior=(θ=randn(4, 100, 4), τ=randn(4, 100)),\n           observed_data=(y=randn(4),),\n           dims=(θ=[:id], y=[:id]),\n           coords=(id=[\"a\", \"b\", \"c\", \"d\"],),\n       )\nInferenceData with groups:\n  > posterior\n  > prior\n  > observed_data\n\njulia> idata.posterior\nDataset with dimensions:\n  Dim{:chain} Sampled 1:4 ForwardOrdered Regular Points,\n  Dim{:draw} Sampled 1:100 ForwardOrdered Regular Points,\n  Dim{:id} Categorical String[a, b, c, d] ForwardOrdered\nand 2 layers:\n  :θ Float64 dims: Dim{:chain}, Dim{:draw}, Dim{:id} (4×100×4)\n  :τ Float64 dims: Dim{:chain}, Dim{:draw} (4×100)\n\nwith metadata OrderedCollections.OrderedDict{Symbol, Any} with 1 entry:\n  :created_at => \"2022-08-11T11:15:21.4\"\n\njulia> idata_sel = idata[id=At([\"a\", \"b\"])]\nInferenceData with groups:\n  > posterior\n  > prior\n  > observed_data\n\njulia> idata_sel.posterior\nDataset with dimensions:\n  Dim{:chain} Sampled 1:4 ForwardOrdered Regular Points,\n  Dim{:draw} Sampled 1:100 ForwardOrdered Regular Points,\n  Dim{:id} Categorical String[a, b] ForwardOrdered\nand 2 layers:\n  :θ Float64 dims: Dim{:chain}, Dim{:draw}, Dim{:id} (4×100×2)\n  :τ Float64 dims: Dim{:chain}, Dim{:draw} (4×100)\n\nwith metadata OrderedCollections.OrderedDict{Symbol, Any} with 1 entry:\n  :created_at => \"2022-08-11T11:15:21.4\"\n\nSelect data from just the posterior, returning a Dataset if the indices index more than one element from any of the variables:\n\njulia> idata[:observed_data, id=At([\"a\"])]\nDataset with dimensions:\n  Dim{:id} Categorical String[a] ForwardOrdered\nand 1 layer:\n  :y Float64 dims: Dim{:id} (1)\n\nwith metadata OrderedCollections.OrderedDict{Symbol, Any} with 1 entry:\n  :created_at => \"2022-08-11T11:19:25.982\"\n\nNote that if a single index is provided, the behavior is still to slice so that the dimension is preserved.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getproperty-Tuple{InferenceData, Symbol}","page":"Home","title":"Base.getproperty","text":"getproperty(data::InferenceData, name::Symbol) -> Dataset\n\nGet group with the specified name.\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{InferenceData, Vararg{InferenceData}}","page":"Home","title":"Base.merge","text":"merge(data::InferenceData, others::InferenceData...) -> InferenceData\n\nMerge InferenceData objects.\n\nThe result contains all groups in data and others. If a group appears more than once, the one that occurs first is kept.\n\n\n\n\n\n","category":"method"},{"location":"#Base.propertynames-Tuple{InferenceData}","page":"Home","title":"Base.propertynames","text":"propertynames(data::InferenceData) -> Tuple{Symbol}\n\nGet names of groups\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex-Tuple{InferenceData, Any, Symbol}","page":"Home","title":"Base.setindex","text":"Base.setindex(data::InferenceData, group::Dataset, name::Symbol) -> InferenceData\n\nCreate a new InferenceData containing the group with the specified name.\n\nIf a group with name is already in data, it is replaced.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.array_to_dimarray-Tuple{Any, Any}","page":"Home","title":"InferenceObjects.array_to_dimarray","text":"array_to_dimarray(array, name; kwargs...) -> DimensionalData.AbstractDimArray\n\nConvert array to a AbstractDimArray with name name.\n\nIf array is already an AbstractDimArray, then it is returned without modification. See generate_dims for a description of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.as_dimension-Tuple{Any, Any, Any}","page":"Home","title":"InferenceObjects.as_dimension","text":"as_dimension(dim, coords, axis) -> DimensionsionalData.Dimension\n\nConvert dim, coords, and axis to a Dimension object.\n\nArguments\n\ndim: An object specifying the name and potentially indices of a dimension. Can be the following types:\nSymbol: dimension name.\nType{<:DimensionsionalData.Dimension}: dimension type\nDimensionsionalData.Dimension: dimension, potentially with indices\ncoords: a collection indexable by dimension name specifying the indices of the given dimension. If indices are provided, they are used even if dim contains its own indices. If a dimension is missing, its indices are automatically generated.\naxis: A default axis to be used if coords and dim indices are not provided.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.convert_to_dataset","page":"Home","title":"InferenceObjects.convert_to_dataset","text":"convert_to_dataset(obj; group = :posterior, kwargs...) -> Dataset\n\nConvert a supported object to a Dataset.\n\nIn most cases, this function calls convert_to_inference_data and returns the corresponding group.\n\n\n\n\n\n","category":"function"},{"location":"#InferenceObjects.convert_to_inference_data","page":"Home","title":"InferenceObjects.convert_to_inference_data","text":"convert_to_inference_data(obj; group, kwargs...) -> InferenceData\n\nConvert a supported object to an InferenceData object.\n\nIf obj converts to a single dataset, group specifies which dataset in the resulting InferenceData that is.\n\nSee convert_to_dataset\n\nArguments\n\nobj can be many objects. Basic supported types are:\nInferenceData: return unchanged\nDataset/DimensionalData.AbstractDimStack: add to InferenceData as the only group\nNamedTuple/AbstractDict: create a Dataset as the only group\nAbstractArray{<:Real}: create a Dataset as the only group, given an arbitrary name, if the name is not set\n\nMore specific types may be documented separately.\n\nKeywords\n\ngroup::Symbol = :posterior: If obj converts to a single dataset, assign the resulting dataset to this group.\ndims: a collection mapping variable names to collections of objects containing dimension names. Acceptable such objects are:\nSymbol: dimension name\nType{<:DimensionsionalData.Dimension}: dimension type\nDimensionsionalData.Dimension: dimension, potentially with indices\nNothing: no dimension name provided, dimension name is automatically generated\ncoords: a collection indexable by dimension name specifying the indices of the given dimension. If indices for a dimension in dims are provided, they are used even if the dimension contains its own indices. If a dimension is missing, its indices are automatically generated.\nkwargs: remaining keywords forwarded to converter functions\n\n\n\n\n\n","category":"function"},{"location":"#InferenceObjects.convert_to_inference_data-Tuple{T} where T<:Union{AbstractVector{<:NamedTuple}, AbstractVector{<:AbstractVector{<:NamedTuple}}, NamedTuple, AbstractMatrix{<:NamedTuple}}","page":"Home","title":"InferenceObjects.convert_to_inference_data","text":"convert_to_inference_data(obj::NamedTuple; kwargs...) -> InferenceData\nconvert_to_inference_data(obj::Vector{<:NamedTuple}; kwargs...) -> InferenceData\nconvert_to_inference_data(obj::Matrix{<:NamedTuple}; kwargs...) -> InferenceData\nconvert_to_inference_data(obj::Vector{Vector{<:NamedTuple}}; kwargs...) -> InferenceData\n\nConvert obj to an InferenceData. See from_namedtuple for a description of obj possibilities and kwargs.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.default_attributes","page":"Home","title":"InferenceObjects.default_attributes","text":"default_attributes(library=nothing) -> NamedTuple\n\nGenerate default attributes metadata for a dataset generated by inference library library.\n\nlibrary may be a String or a Module.\n\n\n\n\n\n","category":"function"},{"location":"#InferenceObjects.default_var_name-Tuple{Any}","page":"Home","title":"InferenceObjects.default_var_name","text":"default_var_name(data) -> Symbol\n\nReturn the default name for the variable whose values are stored in data.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.flatten-Tuple{Any}","page":"Home","title":"InferenceObjects.flatten","text":"flatten(x)\n\nIf x is an array of arrays, flatten into a single array whose dimensions are ordered with dimensions of the outermost container first and innermost container last.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.from_namedtuple","page":"Home","title":"InferenceObjects.from_namedtuple","text":"from_namedtuple(posterior::NamedTuple; kwargs...) -> InferenceData\nfrom_namedtuple(posterior::Vector{<:NamedTuple}; kwargs...) -> InferenceData\nfrom_namedtuple(posterior::Matrix{<:NamedTuple}; kwargs...) -> InferenceData\nfrom_namedtuple(posterior::Vector{Vector{<:NamedTuple}}; kwargs...) -> InferenceData\nfrom_namedtuple(\n    posterior::NamedTuple,\n    sample_stats::Any,\n    posterior_predictive::Any,\n    predictions::Any,\n    log_likelihood::Any;\n    kwargs...\n) -> InferenceData\n\nConvert a NamedTuple or container of NamedTuples to an InferenceData.\n\nIf containers are passed, they are flattened into a single NamedTuple with array elements whose first dimensions correspond to the dimensions of the containers.\n\nArguments\n\nposterior: The data to be converted. It may be of the following types:\n::NamedTuple: The keys are the variable names and the values are arrays with dimensions (nchains, ndraws, sizes...).\n::Matrix{<:NamedTuple}: Each element is a single draw from a single chain, with array/scalar values with dimensions sizes. The dimensions of the matrix container are (nchains, ndraws)\n::Vector{Vector{<:NamedTuple}}: The same as the above case.\n\nKeywords\n\nposterior_predictive::Any=nothing: Draws from the posterior predictive distribution\nsample_stats::Any=nothing: Statistics of the posterior sampling process\npredictions::Any=nothing: Out-of-sample predictions for the posterior.\nprior::Any=nothing: Draws from the prior\nprior_predictive::Any=nothing: Draws from the prior predictive distribution\nsample_stats_prior::Any=nothing: Statistics of the prior sampling process\nobserved_data::NamedTuple: Observed data on which the posterior is conditional. It should only contain data which is modeled as a random variable. Keys are parameter names and values.\nconstant_data::NamedTuple: Model constants, data included in the model which is not modeled as a random variable. Keys are parameter names and values.\npredictions_constant_data::NamedTuple: Constants relevant to the model predictions (i.e. new x values in a linear regression).\nlog_likelihood: Pointwise log-likelihood for the data. It is recommended to use this argument as a NamedTuple whose keys are observed variable names and whose values are log likelihood arrays.\nlibrary: Name of library that generated the draws\ncoords: Map from named dimension to named indices\ndims: Map from variable name to names of its dimensions\n\nReturns\n\nInferenceData: The data with groups corresponding to the provided data\n\nExamples\n\nusing InferenceObjects\nnchains, ndraws = 2, 10\n\ndata1 = (\n    x=rand(nchains, ndraws), y=randn(nchains, ndraws, 2), z=randn(nchains, ndraws, 3, 2)\n)\nidata1 = from_namedtuple(data1)\n\ndata2 = [(x=rand(ndraws), y=randn(ndraws, 2), z=randn(ndraws, 3, 2)) for _ in 1:nchains];\nidata2 = from_namedtuple(data2)\n\ndata3 = [(x=rand(), y=randn(2), z=randn(3, 2)) for _ in 1:nchains, _ in 1:ndraws];\nidata3 = from_namedtuple(data3)\n\ndata4 = [[(x=rand(), y=randn(2), z=randn(3, 2)) for _ in 1:ndraws] for _ in 1:nchains];\nidata4 = from_namedtuple(data4)\n\n\n\n\n\n","category":"function"},{"location":"#InferenceObjects.generate_dims-Tuple{Any, Any}","page":"Home","title":"InferenceObjects.generate_dims","text":"generate_dims(array, name; dims, coords, default_dims)\n\nGenerate DimensionsionalData.Dimension objects for each dimension of array.\n\nname indicates the name of the variable represented by array.\n\nKeywords\n\ndims: A collection of objects indicating dimension names. If any dimensions are not provided, their names are automatically generated. Acceptable types of entries are:\nSymbol: dimension name\nType{<:DimensionsionalData.Dimension}: dimension type\nDimensionsionalData.Dimension: dimension, potentially with indices\nNothing: no dimension name provided, dimension name is automatically generated\ncoords: a collection indexable by dimension name specifying the indices of the given dimension. If indices for a dimension in dims are provided, they are used even if the dimension contains its own indices. If a dimension is missing, its indices are automatically generated.\ndefault_dims: A collection of dims to be prepended to dims whose elements have the same constraints.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.groupnames-Tuple{InferenceData}","page":"Home","title":"InferenceObjects.groupnames","text":"groupnames(data::InferenceData)\n\nGet the names of the groups (datasets) in data as a tuple of symbols.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.groups-Tuple{InferenceData}","page":"Home","title":"InferenceObjects.groups","text":"groups(data::InferenceData)\n\nGet the groups in data as a named tuple mapping symbols to Datasets.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.hasgroup-Tuple{InferenceData, Symbol}","page":"Home","title":"InferenceObjects.hasgroup","text":"hasgroup(data::InferenceData, name::Symbol) -> Bool\n\nReturn true if a group with name name is stored in data.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.index_to_indices-Tuple{Any}","page":"Home","title":"InferenceObjects.index_to_indices","text":"index_to_indices(index)\n\nConvert index to a collection of indices or a selector representing such a collection.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.namedtuple_of_arrays","page":"Home","title":"InferenceObjects.namedtuple_of_arrays","text":"namedtuple_of_arrays(x::NamedTuple) -> NamedTuple\nnamedtuple_of_arrays(x::AbstractArray{NamedTuple}) -> NamedTuple\nnamedtuple_of_arrays(x::AbstractArray{AbstractArray{<:NamedTuple}}) -> NamedTuple\n\nGiven a container of NamedTuples, concatenate them, using the container dimensions as the dimensions of the resulting arrays.\n\nExamples\n\nusing InferenceObjects\nnchains, ndraws = 4, 100\ndata = [(x=rand(), y=randn(2), z=randn(2, 3)) for _ in 1:nchains, _ in 1:ndraws];\nntarray = InferenceObjects.namedtuple_of_arrays(data);\n\n\n\n\n\n","category":"function"},{"location":"#InferenceObjects.namedtuple_to_dataset","page":"Home","title":"InferenceObjects.namedtuple_to_dataset","text":"namedtuple_to_dataset(data; kwargs...) -> Dataset\n\nConvert NamedTuple mapping variable names to arrays to a Dataset.\n\nKeywords\n\nattrs: a Symbol-indexable collection of metadata to attach to the dataset, in addition to defaults. Values should be JSON serializable.\nlibrary::Union{String,Module}: library used for performing inference. Will be attached to the attrs metadata.\ndims: a collection mapping variable names to collections of objects containing dimension names. Acceptable such objects are:\nSymbol: dimension name\nType{<:DimensionsionalData.Dimension}: dimension type\nDimensionsionalData.Dimension: dimension, potentially with indices\nNothing: no dimension name provided, dimension name is automatically generated\ncoords: a collection indexable by dimension name specifying the indices of the given dimension. If indices for a dimension in dims are provided, they are used even if the dimension contains its own indices. If a dimension is missing, its indices are automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"#InferenceObjects.package_version-Tuple{Module}","page":"Home","title":"InferenceObjects.package_version","text":"package_version(pkg::Module) -> Union{Nothing,VersionNumber}\n\nReturn version number of package pkg.\n\nIf pkg does not have a version module (e.g. it is a submodule), then nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"#InferenceObjects.rekey-Tuple{Any, Any}","page":"Home","title":"InferenceObjects.rekey","text":"rekey(collection, keymap) -> rekeyed_collection\n\nReturn a new collection where values for specific keys have been moved to other keys.\n\nkeymap must be a keyed collection mapping from keys of the same type as collection to other keys of the same type.\n\nKeys present in keymap but absent from collection are ignored.\n\n\n\n\n\n","category":"method"}]
}
